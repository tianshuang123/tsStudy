# 策略模式

## 1.什么是策略模式

策略模式是一种行为型设计模式，它定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换或独立于使用它的客户而变化。这种类型的设计模式属于行为型模式。当在处理一项业务时，如果有多种处理方式，并且需要再运行时决定使用哪一种具体实现，就会使用策略模式。

策略模式的主要组成部分包括抽象策略（Strategy）类、具体策略（Concrete Strategy）类和环境（Context）类。抽象策略类是策略接口，定义了所有支持的算法；具体策略类是实现了抽象策略接口的类，表示每种具体的算法；环境类则负责接受客户的请求，并确定使用哪种具体策略来处理该请求。

策略模式的优点在于降低系统的耦合度，提高系统的灵活性和扩展性。缺点在于增加了系统的复杂性和理解难度。

## 2.策略模式结构图

![image-20240806213440871](http://117.72.43.140:9000/weblog/image-20240806213440871.png)

## 3.简单策略模式实现

1.定义一个公共接口

```java
public interface Strategy {
    void execute();
}
```

2.创建具体实现类

```java
public class ConcreteStrategyA implements Strategy {
    @Override
    public void execute() {
        System.out.println("执行策略A");
    }
}

public class ConcreteStrategyB implements Strategy {
    @Override
    public void execute() {
        System.out.println("执行策略B");
    }
}
```

3.创建一个上下文类，用于管理策略：

```java
public class StrategyContext {
    private Strategy strategy;

    public StrategyContext(Strategy strategy) {
        this.strategy = strategy;
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public void executeStrategy() {
        strategy.execute();
    }
}
```

4.测试执行

```java
public static void main(String[] args) {
    StrategyContext context = new StrategyContext(new ConcreteStrategyA()); // 使用策略A初始化上下文对象
    context.executeStrategy(); // 输出：执行策略A
    context.setStrategy(new ConcreteStrategyB()); // 更改上下文对象的策略为策略B
    context.executeStrategy(); // 输出：执行策略B
}
```

这时候就实现了一个简单的策略模式。

## 4.在springBoot项目中，通过策略模式实现if-else的去除。

1.创建策略接口

```java
public interface Strategy {
    void execute();
}
```

2.具体策略实现类并交给容器管理

```java
@Component
public class ConcreteStrategyA implements Strategy {
    @Override
    public void execute() {
        System.out.println("执行策略A");
    }
}

@Component
public class ConcreteStrategyB implements Strategy {
    @Override
    public void execute() {
        System.out.println("执行策略B");
    }
}
```

3.策略上下文

```java
public class StrategyContext {
    private Strategy strategy;

    public StrategyContext(Strategy strategy) {
        this.strategy = strategy;
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public void executeStrategy() {
        strategy.execute();
    }
}
```

4.通过简单工厂获取具体策略类

```java
@Component
public class StrategyFactory {
    @Autowired
    private  Map<String, Strategy> strategyMap;


    public Strategy getStrategy(String strategyType) {//strategyType为具体实现类bean的名字
        return strategyMap.get(strategyType);
    }
}
```

5.简单测试

```java
@RestController
public class StrategyTestController {

    @Autowired
    StrategyFactory factory;
    @RequestMapping("/test1/{strategy}")
    public String test01(@PathVariable String strategy){
        Strategy strategy1 = factory.getStrategy(strategy);
        StrategyContext context = new StrategyContext(strategy1); // 使用策略A初始化上下文对象
        context.executeStrategy(); // 输出：执行策略A
        return "OK";
    }
}
```

6.结果

![image-20240806215244167](http://117.72.43.140:9000/weblog/image-20240806215244167.png)

![image-20240806215306515](http://117.72.43.140:9000/weblog/image-20240806215306515.png)

这样就可以根据不同条件去执行不同的策略了。

